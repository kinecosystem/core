#include "main/Whitelist.h"
#include "ledger/DataFrame.h"
#include "transactions/SignatureUtils.h"
#include "transactions/TransactionFrame.h"
#include "util/Logging.h"
#include <stdint.h>
#include <numeric>
#include <unordered_map>
#include <unordered_set>

namespace stellar
{
const int32_t WHITELIST_PRIORITY_MAX = 0x7fffffff; // MAX of int32_t
const int32_t WHITELIST_PRIORITY_NONE = 0;

// Available whitelisted capacity is split by whitelist priority.
// Higher priorities receive a proportionally-larger percentage of
// available capacity.
std::vector<size_t>
fairDistribution(size_t capacity, size_t slices)
{
    const int ratio = 50;
    size_t distributed = 0;
    std::vector<size_t> distribution = {};

    distribution.resize(slices);

    for (int i = 0; i < slices; i++) {
        auto allocation = (capacity - distributed) * ratio / 100;
        distributed += allocation;
        distribution[i] = allocation;
    }

    distribution[0] += capacity - std::accumulate(distribution.begin(),
                                                  distribution.end(),
                                                  0);

    return distribution;
}

std::string
Whitelist::getAccount()
{
    return mApp.getConfig().WHITELIST;
}

void Whitelist::fulfill(std::vector<DataFrame::pointer> dfs)
{
    std::unordered_set<int32_t> prioritySet;

    whitelist.clear();

    // Iterate DataFrames to build the whitelist.
    // Structure: hash of (hint, vector of WhitelistEntry)
    // The hint is the last 4 bytes of the public key, and is used to
    // efficiently filter the possible entries for a given signature.
    for (auto& df : dfs)
    {
        auto data = df->getData();
        auto name = data.dataName;
        auto value = data.dataValue;

        // If the value isn't 4 or 8 bytes long, skip the entry.
        if (value.size() != 4 && value.size() != 8)
        {
            CLOG(INFO, "Whitelist")
            << "bad value for: " << name;

            continue;
        }

        // The first integer stored in value will be either the reserve
        // or the signature hint.
        int32_t intVal, priority;

        intVal =
            (value[0] << 24) + (value[1] << 16) +
            (value[2] << 8) + value[3];

        if (value.size() == 8)
            priority =
            (value[4] << 24) + (value[5] << 16) +
            (value[6] << 8) + value[7];
        else
            priority = WHITELIST_PRIORITY_MAX;

        // Collect the distinct set of priorities.
        prioritySet.insert(priority);

        // The DataFrame entry is the percentage to reserve for
        // non-whitelisted txs.
        // Store the value and continue.
        if (name == "reserve")
        {
            auto reserve = intVal;

            // clamp the value between 1 and 100.
            reserve = std::max(1, reserve);
            reserve = std::min(100, reserve);

            mReserve = (double)reserve / 100;

            continue;
        }

        try
        {
            // An exception is thrown if the key isn't convertible.
            // If this occurs, the entry is skipped.
            KeyUtils::fromStrKey<PublicKey>(name);
        }
        catch (...)
        {
            CLOG(INFO, "Whitelist")
            << "bad public key: " << name;

            continue;
        }

        auto hint = intVal;

        auto keys = whitelist[hint];
        keys.emplace_back(WhitelistEntry({name, priority}));
        whitelist[hint] = keys;
    }

    mPriorities.clear();

    if (prioritySet.size() == 0)
    {
        mDistribution.clear();

        return;
    }

    // Sort priorities in descending order.
    mPriorities.insert(mPriorities.end(),
                       prioritySet.begin(), prioritySet.end());
    std::sort(mPriorities.begin(), mPriorities.end(), std::greater<int32_t>());

    // Refresh the distribution.
    auto capacity = mApp.getLedgerManager().getMaxTxSetSize();
    mDistribution = fairDistribution(capacity - unwhitelistedReserve(capacity),
                                     mPriorities.size());

    mTxSetSize = capacity;
}

void
Whitelist::refreshDistribution()
{
    auto current = mApp.getLedgerManager().getMaxTxSetSize();
    if (mTxSetSize == current || mPriorities.size() == 0)
        return;

    mDistribution = fairDistribution(current - unwhitelistedReserve(current),
                                     mPriorities.size());

    mTxSetSize = current;
}

// Translate the reserve percentage into the number of entries to reserve,
// for a given set size.
size_t
Whitelist::unwhitelistedReserve(size_t setSize)
{
    size_t reserve = size_t(std::trunc(mReserve * setSize)); 
	
	// reserve at least 1 entry for non-whitelisted txs
	reserve = std::max((size_t)1, reserve);

	return reserve;
}

// Determine if a tx is whitelisted.  This is done by checking each
// signature to see if it was generated by a whitelist entry.
int32_t
Whitelist::priority(std::vector<DecoratedSignature> signatures,
                    Hash const& txHash)
{
    for (auto& sig : signatures)
    {
        auto p = signerPriority(sig, txHash);
        if (p != WHITELIST_PRIORITY_NONE)
            return p;
    }

    return WHITELIST_PRIORITY_NONE;
}

// Returns the priority of the signer, if any.
// Returns WHITELIST_PRIORITY_NONE if the signer isn't on the whitelist.
int32_t
Whitelist::signerPriority(DecoratedSignature const& sig, Hash const& txHash)
{
	// Obtain the possible keys by indexing on the hint.

    int32_t hintInt = (sig.hint[0] << 24) + (sig.hint[1] << 16) +
                      (sig.hint[2] << 8) + sig.hint[3];

    auto it = whitelist.find(hintInt);

	// Iterate through the public keys with the same hint as the signature.
	// Expected vector size is 1, due to randomness in creating keys.
    if (it != whitelist.end())
    {
        for (auto wlEntry : it->second)
        {
            auto pkey = KeyUtils::fromStrKey<PublicKey>(wlEntry.key);

            if (PubKeyUtils::verifySig(pkey, sig.signature, txHash))
            {
                return wlEntry.priority;
            }
        }
    }

    // Check if the signer is the whitelist holder's account.
    auto holder = accountID().get();
    if (holder && PubKeyUtils::verifySig(*holder, sig.signature, txHash))
        return WHITELIST_PRIORITY_MAX;

    return WHITELIST_PRIORITY_NONE;
}
} // namespace stellar
